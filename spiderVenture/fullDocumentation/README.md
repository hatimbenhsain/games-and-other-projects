## The game:

The first thing I worked on was making the spider. I took inspiration from [Mimi](https://youtu.be/cPCDJbI9yYA) from Super Paper Mario, [this gif](https://dribbble.com/shots/4376525-2-Dribbble-Invite-Spider-Dribbble), and mobile game [Daddy Long Legs](https://play.google.com/store/apps/details?id=com.setsnail.daddylonglegs). What I liked about these examples is the mechanical, almost mesmerizing way their walk cycle was animated, but also how unsteady it looked all the time, so I spend the most time working on my project making my spider and working on how it moved.

I used Processing and the library Box2D, which I learnt about from Daniel Shiffman's Nature of Code book and YouTube videos. The spider is constituted of a trapezoidal body, connected by revolute joints to 6 short leg parts, all respectively connected with another revolute join to a longer leg part. In the code, the makeLeg function is called 6 times within the makeBody function to achieve this. Within makeLeg, a different angle is picked for the leg depending on its index (with a PI/16 different each), and the angle of the long part of the leg is adjusted so that they all have the same length and still touch the ground. All the legs have a same angle wiggle room that they can move around in, and motors that are disabled at the start. 

After building the spider, I started working on its movement. I decided preminilarily to have the buttons A, S, and D each move a different pair of legs by activating the motors and deactivating them at button release, until I found a way to automate the walking with one button. To do this, I took inspiration from Daniel Shiffman's Evolution of Code chapter about machine learning, and I built a system where a population of 50 spiders would move their legs at random rhythms, and the ones that got farther on the x-axis would have a higher fitness index than others when reproducing. However, after running this for several hours and after more than a thousand generations of spiders, I realized that not a lot - if any - progress was made, so I just scrapped the concept. Instead, I focused on improving the buttons I already had for walking. I did this by setting the lower and upper angle boundaries to 0 or the other legs to 0 when 2 were being moved, so that the Spider would be slightly less shaky, and restoring them later whenever another pair of legs was being moved. I also attempted to automatize the walk cycle based on how I would normally behave with the spider by making the right-direction button move each pair succeedingly for a few seconds. This method is more reliable than pressing the buttons individually, but won't get you very far in the long term.

When working on the spider's animation, I noticed that if I locked every joint in the spider's body and pressed buttons too fast, it would cause the spider's legs to go in crazy random directions. After I fixed the problem, I was still fascinated by how the crazy spiders looked, so I decided to create a new class called Fallen. This Fallen class would be indentical to the Spider class, except that the lines of code that would cause it to go crazy were still there, and I decided to use them as the ennemies of the game. Because the player doesn't control them, I added an update function that makes it go through the movement that would make it go crazy for the first 30 frames of its creation. I also made it so that the Fallen are only added in the game when the player gets close enough to them and that they get deleted once the player gets past them, so that they wouldn't mess too much with the rest of the game or cause a drop in framerate since they were still essentially glitches. 

Then I started working on the actual game. The first part was what I imagined to be a descent as the spider hang from a thread and it had to avoid obstacles. The obstacles take the form of platforms from the Boundaries class, which I took from a Daniel Shiffman tutorial, and the Fallen spiders, which do not actually harm you but can be annoying nonetheless. I built a Thread class, which is essentially just an object located offscreen on top, a distance joint, and a line drawn between it and the Spider. When the player presses c, the thread is destroyed with the hack function and this is shown by drawing the line progressively shorter until it disappears. I also added a wind mechanic, where pressing left or right while the spider is hanging causes it to sway to avoid the obstacles by applying an appropriate force to the spider's body. Pressing up and down makes the thread longer or shorter. Finally, I added an idle animation to the spider where the perlin noise function integrated in Processing cause the legs to move on their own. 

For the level itself, I tried to have a mix of small obstacles to avoid, narrow holes between boundaries to slip into, and creepy fallen here and there. I added text that appears and disappears which explain to the player the premise of the game: "This is your spider. You have to take care of it." The only instruction on this stage is to press down to descend, and I figured most players would instinctively think to press left and right, which they did during the playtest. However, not a lot of them tried the up button unless I pointed it out, so I could've made that clearer. 

As to the second part of the game, after the player gets to the bottom and hacks the thread, I initially wanted to have an infinite runner-esque game where something (more Fallen?) pursued the player and you had to run. The player though was that walking was already hard enough, and landing on the spider's feet instead of its head (rendering it powerless) was a challenge in itself. When I gave one of my friends the game to test, she spent about 10 minutes just having fun trying to make the spider walk, so in the end, I just decided to have an infinite walking simulator, until the player gets bored and resets the game by pressing the spacebar. So at the end, the game becomes less of a game than a toy, which is also fine. Here, blinking instructions tell the player to press A, S or D to move the legs, but they completely disappear after a few seconds so as to give the player a completely empty playground. The Surface on the bottom is a modified Boundary that uses noise to create a slightly uneven shape to simulate textured ground. 

## The music:

To create the music, I took inspiration from 8-bit sounding music from games I like such as [Once Upon a Time](https://youtu.be/s7RRgF5Ve_E) from Undertale, and the [Moon Theme](https://youtu.be/KF32DRg9opA) from DuckTales. I used Logic Pro X, [the magical 8bit plug](http://www.ymck.net/en/download/magical8bitplug/), and soundfonts from EarthBound and Chrono Trigger. I composed a few tracks for the game which are all collected in [this medley](https://soundcloud.com/hatim-benhsain/spider-medley), but I only used four of them:

- The intro theme, an atmospheric song which plays at the beginning.
- The descent theme, which is the intro with more instruments and an actual melody going on, which plays while the player is descending through the stage.
- The level theme, which plays after the thread is hacked and is meant to sound more upbeat than the other themes to represent the new freedom the player gets.
- The idle theme, which plays if the player stops pressing any button.

After composing the music, I made a Max patch that hosted all the tracks and I used the matrix object to be able to control the levels of every song. Then, I used the oscP5 library on Processing to send messages from Processing to Max. The messages have volumes for all the tracks and come in four natures:

1 The message that is sent once when the setup function is called, which starts the intro and the descent theme from the beginning, setting intro at volume 100 and descent at volume 0.
2 The message that gets sent every frame until the thread is hacked and has different volumes for intro and descent depending on the last time a button was pressed.
3 The message that is sent once when the thread is hacked and stops the intro and descent theme and starts the level and the idle theme, setting level at volume 100 and idle at 0.
4 The message that adjusts the volumes of level and idle.

When making the music, I gave all the tracks the same tempo and a similar length such that they could easily be switched out, and I made the volume of the corresponding tracks fade in and out when a button has or hasn't been pressed for too long. This way, the changes are never jarring and maintain a consistent aesthetic.
